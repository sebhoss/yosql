<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>write more SQL on YoSQL - write more SQL</title><link>https://yosql.projects.metio.wtf/</link><description>Recent content in write more SQL on YoSQL - write more SQL</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 13 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://yosql.projects.metio.wtf/index.xml" rel="self" type="application/rss+xml"/><item><title>Annotations</title><link>https://yosql.projects.metio.wtf/configuration/annotations/</link><pubDate>Fri, 27 Sep 2019 18:51:08 +0200</pubDate><guid>https://yosql.projects.metio.wtf/configuration/annotations/</guid><description>annotateClasses Should @Generated annotations be added to generated classes?. Defaults to false.
Configuration Options Option: &amp;lsquo;false&amp;rsquo; The default value of the classGeneratedAnnotation is false. Setting the option to false therefore produces the same code generated as the default configuration.
package com.example.persistence; public class SomeRepository { // ... rest of generated code } Option: &amp;lsquo;true&amp;rsquo; Changing the annotateClasses configuration option to true adds the @Generated annotation to every generated class. Its is possible to configure each value individually using other config options (TODO: link here?</description></item><item><title>JDBC</title><link>https://yosql.projects.metio.wtf/api/jdbc/</link><pubDate>Fri, 27 Sep 2019 18:51:08 +0200</pubDate><guid>https://yosql.projects.metio.wtf/api/jdbc/</guid><description>The javax.sql based implementation.</description></item><item><title>jOOQ</title><link>https://yosql.projects.metio.wtf/api/jooq/</link><pubDate>Fri, 27 Sep 2019 18:51:08 +0200</pubDate><guid>https://yosql.projects.metio.wtf/api/jooq/</guid><description>The jOOQ based implementation.</description></item><item><title>JPA</title><link>https://yosql.projects.metio.wtf/api/jpa/</link><pubDate>Fri, 27 Sep 2019 18:51:08 +0200</pubDate><guid>https://yosql.projects.metio.wtf/api/jpa/</guid><description>The JPA based implementation.</description></item><item><title>JUL</title><link>https://yosql.projects.metio.wtf/logging/jul/</link><pubDate>Fri, 27 Sep 2019 18:51:08 +0200</pubDate><guid>https://yosql.projects.metio.wtf/logging/jul/</guid><description>The java.util.logging based implementation.</description></item><item><title>log4j</title><link>https://yosql.projects.metio.wtf/logging/log4j/</link><pubDate>Fri, 27 Sep 2019 18:51:08 +0200</pubDate><guid>https://yosql.projects.metio.wtf/logging/log4j/</guid><description>The log4j based implementation.</description></item><item><title>no-op</title><link>https://yosql.projects.metio.wtf/logging/no-op/</link><pubDate>Fri, 27 Sep 2019 18:51:08 +0200</pubDate><guid>https://yosql.projects.metio.wtf/logging/no-op/</guid><description>The no-op based implementation.</description></item><item><title>Repositories</title><link>https://yosql.projects.metio.wtf/configuration/repositories/</link><pubDate>Fri, 27 Sep 2019 18:51:08 +0200</pubDate><guid>https://yosql.projects.metio.wtf/configuration/repositories/</guid><description>basePackageName The base package name for the generated code. Defaults to com.example.persistence.
package com.example.persistence; public class SomeRepository { // ... rest of generaed code } Changing the basePackageName configuration option to your.own.domain generates the following code instead:
package your.own.domain; public class SomeRepository { // ... rest of generated code (same as above) }</description></item><item><title>slf4j</title><link>https://yosql.projects.metio.wtf/logging/slf4j/</link><pubDate>Fri, 27 Sep 2019 18:51:08 +0200</pubDate><guid>https://yosql.projects.metio.wtf/logging/slf4j/</guid><description>The slf4j based implementation.</description></item><item><title>Spring-Data-JDBC</title><link>https://yosql.projects.metio.wtf/api/spring_data_jdbc/</link><pubDate>Fri, 27 Sep 2019 18:51:08 +0200</pubDate><guid>https://yosql.projects.metio.wtf/api/spring_data_jdbc/</guid><description>The spring-data-jdbc based implementation.</description></item><item><title>Spring-JDBC</title><link>https://yosql.projects.metio.wtf/api/spring_jdbc/</link><pubDate>Fri, 27 Sep 2019 18:51:08 +0200</pubDate><guid>https://yosql.projects.metio.wtf/api/spring_jdbc/</guid><description>The spring-jdbc based implementation.</description></item><item><title>Converters</title><link>https://yosql.projects.metio.wtf/integration/converters/</link><pubDate>Sun, 07 Jul 2019 14:29:29 +0200</pubDate><guid>https://yosql.projects.metio.wtf/integration/converters/</guid><description>Changing the result type is possible with the help of a converter:
-- parameters: -- - name: userId -- type: int -- results: -- converter: my.own.UserConverter -- resultType: my.own.User SELECT * FROM users WHERE id = :userId Which in turn changes the generated code into this:
// uses &amp;#39;User&amp;#39; instead of &amp;#39;ResultRow&amp;#39; &amp;amp; &amp;#39;int&amp;#39; instead of &amp;#39;Object&amp;#39; List&amp;lt;User&amp;gt; findUser(int userId) Stream&amp;lt;User&amp;gt; findUserStreamEager(int userId) Stream&amp;lt;User&amp;gt; findUserStreamLazy(int userId) Flowable&amp;lt;User&amp;gt; findUserFlow(int userId) my.own.UserConverter could look like this:</description></item><item><title>Reactive</title><link>https://yosql.projects.metio.wtf/integration/reactive/</link><pubDate>Sun, 07 Jul 2019 14:27:54 +0200</pubDate><guid>https://yosql.projects.metio.wtf/integration/reactive/</guid><description>YoSQL supports several reactive APIs like rxJava or reactor.
The yosql-maven-plugin automatically enables reactive methods like the following in case a reactive API was detected as a dependency of the current project.
// lazily loads all rows in a stateful flow which closes automatically Flowable&amp;lt;ResultRow&amp;gt; findUserFlow(Object userId)</description></item><item><title>Type Safety</title><link>https://yosql.projects.metio.wtf/integration/type-safety/</link><pubDate>Sun, 16 Jun 2019 18:53:54 +0200</pubDate><guid>https://yosql.projects.metio.wtf/integration/type-safety/</guid><description>&amp;lt;project_root&amp;gt;/ └── src/ └── main/ └── yosql/ └── user/ ├── findUser.sql └── getAllUsers.sql The findUser.sql file:
SELECT * FROM users WHERE id = :userId The type of the generated userId parameter will default to java.lang.Object as long as no other information is given. YoSQL does not parse your database schema, nor does it somehow infer the type of userId using some smart algorithm. Instead, it relies on its users to do the work (sorry!</description></item><item><title>Custom</title><link>https://yosql.projects.metio.wtf/integration/custom/</link><pubDate>Sun, 16 Jun 2019 18:51:48 +0200</pubDate><guid>https://yosql.projects.metio.wtf/integration/custom/</guid><description>It is possible to use yosql-core as an external dependency and build your own code generator on top.</description></item><item><title>Vendor Statements</title><link>https://yosql.projects.metio.wtf/sql/vendor-statements/</link><pubDate>Sun, 16 Jun 2019 18:51:18 +0200</pubDate><guid>https://yosql.projects.metio.wtf/sql/vendor-statements/</guid><description>Vendor specific statements are support as well. Just add a vendor key to your front-matter like this:
-- name: findUsers -- vendor: Oracle SELECT * FROM ( SELECT ROWNUM rn, data.* FROM ( SELECT * FROM users WHERE id = :userId ) data WHERE rn &amp;lt;= :offset + :limit ) WHERE rn &amp;gt;= :offset ; -- name: findUsers -- vendor: PostgreSQL SELECT * FROM users WHERE id = :userId OFFSET :offset FETCH NEXT :limit ROWS ONLY ; -- name: findUsers SELECT * FROM users WHERE id = :userId OFFSET :offset LIMIT :limit ; The first two statements specify a vendor which means that those queries will only be executed when running against the specified database.</description></item><item><title>Write Sql Files</title><link>https://yosql.projects.metio.wtf/sql/write-sql-files/</link><pubDate>Sun, 16 Jun 2019 18:33:06 +0200</pubDate><guid>https://yosql.projects.metio.wtf/sql/write-sql-files/</guid><description>&amp;lt;project_root&amp;gt;/ └── src/ └── main/ └── yosql/ └── user/ └── getAllUsers.sql The SQL statements in your .sql files are just plain SQL, e.g. you can save the following statement in a file called getAllUsers.sql:
SELECT * FROM users YoSQL will use the name of the file (getAllUsers) as the generated method name and the name of the enclosing folder as the prefix for the generated repository. The final result is a new Java class called UserRepository which has a method called getAllUsers.</description></item><item><title>CLI</title><link>https://yosql.projects.metio.wtf/tooling/cli/</link><pubDate>Sun, 16 Jun 2019 18:23:45 +0200</pubDate><guid>https://yosql.projects.metio.wtf/tooling/cli/</guid><description> Download the latest release Write .sql files in a directory of your choice (e.g. /path/to/your/sql/files) Call java -jar yosql-cli.jar --inputBaseDirectory /path/to/your/sql/files --outputBaseDirectory /output/path</description></item><item><title>Maven</title><link>https://yosql.projects.metio.wtf/tooling/maven/</link><pubDate>Sun, 16 Jun 2019 18:23:40 +0200</pubDate><guid>https://yosql.projects.metio.wtf/tooling/maven/</guid><description>Getting Started Add the plugin to your pom.xml: &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; ... &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;wtf.metio.yosql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;yosql-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; ... &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; Add .sql files in src/main/yosql and write SQL statements into them. &amp;lt;project_root&amp;gt;/ ├── pom.xml └── src/ └── main/ └── yosql/ └── domainObject/ ├── yourQuery.sql └── changeYourData.sql └── aggregateRoot/ ├── anotherQuery.sql └── addData.sql Execute the yosql:generate goal (or just run mvn generate-sources) to generate the Java code. Configuration You can configure how YoSQL operates and how the generated code like by using the default Maven configuration mechanism (TODO: add link).</description></item><item><title>Alternatives</title><link>https://yosql.projects.metio.wtf/project/alternatives/</link><pubDate>Sun, 16 Jun 2019 18:23:25 +0200</pubDate><guid>https://yosql.projects.metio.wtf/project/alternatives/</guid><description>Here is an incomplete list of tools that we consider to be close siblings to YoSQL:
https://github.com/krisajenkins/yesql https://www.hugsql.org/ https://github.com/OpenGamma/ElSql https://sqlc.dev/ (Go)</description></item><item><title>Scope and Vision</title><link>https://yosql.projects.metio.wtf/project/scope-and-vision/</link><pubDate>Sun, 16 Jun 2019 18:23:25 +0200</pubDate><guid>https://yosql.projects.metio.wtf/project/scope-and-vision/</guid><description>vision:
zero runtime dependencies as few surprises as possible should never fail correct code over performance scope:
all existing database access APIs java/jvm only all existing build tools out-of-scope:
transaction management object mapping SQL parsing/understanding</description></item><item><title>Bazel</title><link>https://yosql.projects.metio.wtf/tooling/bazel/</link><pubDate>Sun, 16 Jun 2019 18:22:51 +0200</pubDate><guid>https://yosql.projects.metio.wtf/tooling/bazel/</guid><description>Add git repository to your WORKSPACE: git_repository( name = &amp;quot;yosql&amp;quot;, remote = &amp;quot;https://github.com/sebhoss/yosql.git&amp;quot;, tag = &amp;quot;0.0.1-bazel&amp;quot;, ) Write .sql files in a directory of your choice (e.g. persistence) project/ ├── WORKSPACE └── persistence/ ├── BUILD └── user/ ├── findUser.sql └── addUser.sql └── item/ ├── queryAllItems.sql └── createItemTable.sql Declare a genrule in one of your BUILD files: filegroup( name = &amp;quot;your-sql-files&amp;quot;, srcs = glob([&amp;quot;persistence/**/*.sql&amp;quot;]), ) genrule( name = &amp;quot;yosql-example&amp;quot;, srcs = [&amp;quot;:your-sql-files&amp;quot;], outs = [ &amp;quot;com/example/persistence/UserRepository.</description></item></channel></rss>